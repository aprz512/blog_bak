---
title: 番外篇：重定位
date: 2020-8-27
categories: C++
---

很久很久以前，在一个非常遥远的银河系......

在最开始的时候，程序员需要先将程序写在纸上。当程序要被运行的时候，程序员人工的将它写的程序写到储存设备上，最原始的储存设备是纸带，即在纸上打孔。

假设有一种计算机，它的每条指令是1个字节，也就是8位。我们假设有一种跳转指令，它的高4位是 0001，表示这是一种跳转指令。低4位存放的是跳转目的的绝对地址。

```
0 0001 0100
1 ...
2 ...
3 ...
4 1000 0111
5 ...
```

看上面的例子，这个程序的第一条指令是一个跳转指令，它的目的地址是第 5 跳指令（**注意，第 5 条指令的绝对地址是 4**）。

现在问题来了，程序写好了之后，并不是永远不变的。比如，我们想在第1条指令之后，第5条指令之前加入某些指令，那么第5条指令及后面的指令需要相应的往后移动，且第1条指令的目的地址也需要调整。在这个过程中程序员需要人工的重新计算每个子程序或跳转的目标地址。当程序修改的时候，这些位置都要重新计算，非常容易出错，而且又耗时。**这样重新计算各个目标的地址的过程就叫做重定位**。

如果，某个程序需要多个纸带储存，那么就会出现跨纸带跳转的情况，那么重定位就更加复杂了。

这个时候，汇编语言就出现了。汇编语言使用符号与标记来解决这些问题。举个例子，在前面的程序中，我们将第5条指令开始的子程序叫做 foo，那么第1条汇编就可以写成：

```
jmp foo
```

使用了符号命令的子程序之后，不管 foo 之前插入或删除了多少指令，汇编器在每次汇编程序的时候，都会重新计算 foo 子程序的地址。然后将所有引用 foo 的指令修改位这个正确的地址。

**符号**，表示一个地址，这个地址可能是一段子程序的地址地址，也可能是一个变量的起始地址。


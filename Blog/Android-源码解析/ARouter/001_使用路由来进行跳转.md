---
title: 001_使用路由来进行跳转
date: 2020-10-28
categories: ARouter
---

> 该系列假设你对注解处理器与gradle插件很熟悉

项目进行组件化之后，组件之间的代码在编译期是隔离的，无论是使用 runtimeOnly 依赖，还是什么方案。组件A的界面想要跳转到组件B的界面，由于无法直接访问到组件 B 的类，所以，跳转也就无法进行。当然，可以使用隐式跳转（action 或者 data等），或者反射，但是实践起来，还是麻烦了些。

ARouter 就提供了一种解决方案，大致使用如下：

```java
// 在支持路由的页面上添加注解(必选)
// 这里的路径需要注意的是至少需要有两级，/xx/xx
@Route(path = "/test/activity")
public class YourActivity extend Activity {
    ...
}
```

跳转到 YourActivity 的时候，这样写：

```java
// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)
ARouter.getInstance().build("/test/activity").navigation();

// 2. 跳转并携带参数
ARouter.getInstance().build("/test/1")
            .withLong("key1", 666L)
            .withString("key3", "888")
            .withObject("key4", new Test("Jack", "Rose"))
            .navigation();
```

这样的话，我们的代价就只是需要为目标 activity 声明一个注解而已，然后，跳转的时候，指定目标 activity 的 path 即可，有点像是进行一个 http 的路径跳转。

那么，它是如何实现的呢？

其实，大致的步骤如下：

1. 使用注解处理器生成类，这个类会统计该module下的所有被Route修饰的类

   如何统计呢？就是在生成的这个类中，使用 Map 将注解里面的 path 与这个类的类信息对应起来

   ```java
   public class ARouter$$Group$$test implements IRouteGroup {
     @Override
     public void loadInto(Map<String, Activity> atlas) {
       atlas.put("/test/activity2", YourActivity.class);
     }
   }
   ```

   当然，这里是我简化过之后的代码，不是ARouter的真实代码，我们的目标是搞清楚他到底做了什么，所以省略一些其他的东西。

2. 有了第一步提供的映射表，那么我们是不是就能进行组件之间的跳转了呢？很遗憾，并不行，因为注解处理器生成的代码，只能在该Module中使用。这就很沙雕了，我们又回到了原来的困境，就算我们统计了映射关系，但是这个映射关系，别人不能访问，那有个毛用！！！

   这个时候，必然要有一个牛逼的东西无视Module的限制才行，是什么呢？有两种解决方案。

   一种是，我们遍历dex中的所有类，将以 `ARouter$$Group`开头的类，全部找出来，使用反射实例化，这样我们就得到了所有module的映射表，想要跳转就变得可能了。

   另外一种是使用 transform api，这个东西他会扫描所有的 class，做一些操作，我们就可以利用这个特性，写一个 transform，统计所有的 class，找到以  `ARouter$$Group`开头的class。有了 class 类信息，我们就可以预留一个空方法，然后在这个空方法里面来实现所有 Module 的映射表加载。

   在编译器间，我们是拿不到以  `ARouter$$Group`开头的类，强制写这些类会报红线，但是在 transform 中我们可以生成字节码来做这件事（相当于跳过java，直接生成了class），打成apk后，class都在一起，所以就不会出现问题。

下面，我们直接实现一个简化版的 BRouter，来演示这些步骤。


---
title: 0002-监控页面的销毁
date: 2019-9-25
tags: Android源码解析-LeakCanary
categories: LeakCanary
---

## 使用

首先，还是要说一下使用，非常的简单：

```groovy
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'
    releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'
    // Optional, if you use support library fragments:
    debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'
```

我这里依赖的版本是 1.6.3，所以源码分析也是基于这个版本的。最新的 2.0 版变化也是很大的，但是核心原理差不多，分析原理还是老一点的版本比较好，思路更清晰，逻辑分支更少。

releaseImplementation 表示打 release 版本的时候会依赖这个包。`leakcanary-android-no-op` 这个依赖包的名字意思也很明显，这个依赖包里面只有两个类，而且类的方法都是空方法，里面啥都不做，因为如果在 release 版也依赖 LeakCanary 的话，用户就会很奇怪了，而且会影响性能。当然你也可以选择在打 release 包的时候将依赖包与相关代码移除，这样就是比较麻烦。

`leakcanary-support-fragment` 这个依赖包是表示如果你的 Fragment 使用了 support 包里面的 Fragment，那么就应该使用这个依赖包，具体为啥，源码里面分析，这个依赖包里面也就一个类。



## 监控页面的方法

我们想要监控页面（Activity 与 Fragment），需要做如下配置：

```java
// this 是 Application 对象
LeakCanary.install(this);
```

因为，LeakCanary 会单独开一个进程用来做 .hprof 文件分析，所以需要排除分析进程。

```java
protected void initCanary() {
    if (LeakCanary.isInAnalyzerProcess(this)) {
        return;
    }
    LeakCanary.install(this);
    BlockCanary.install(this, new AppBlockCanaryHelper()).start();
}
```

里面判断进程的逻辑可以自行去了解一下。



想要监控其他对象，需要做如下配置：

```java
public abstract class BaseService extends Service {

  @Override public void onDestroy() {
    super.onDestroy();
    RefWatcher refWatcher = MyApp.getRefWatcher();
    // 可以传入任何对象
    refWatcher.watch(this);
  }
}
```

这里使用了 RefWatcher 来监控 Service。同样的，你也可以监控其他对象，比如 Bitmap，数组 等。



## 如何做到对页面的监控的

监控 Activity 比较简单，我们都能想的到，使用 `ActivityLifecycleCallbacks` 即可。源码里面也是这样实现的。但是 Fragment 是如何监控的呢？？？

下面，我们开始分析源码。

> com.squareup.leakcanary.LeakCanary#install

```java
  public static @NonNull RefWatcher install(@NonNull Application application) {
    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
        .buildAndInstall();
  }
```

一个链式调用。

`refWatcher` 是创建一个 Builder 对象。

`listenerServiceClass` 是起一个 Service，当然这里还没有真正的启动，只是做了准备工作，因为是 builder 模式，所以至少需要调用 build 后才会启动。

`excludedRefs` 是排除一些引用，这是啥意思呢，是因为 Android SDK 本身也会导致一些内存泄露问题，所以需要将这些问题排除，显然，这个类会一直更新，我们也可以贡献一下，比如我们会在华为的手机上遇到“键盘导致的泄露的问题”，但是实际上是没有泄露的，别的手机都没有出现过这个问题，而且代码最终到了 SDK 里面。有兴趣的可以去看看这个类 `com.squareup.leakcanary.AndroidExcludedRefs`。

`buildAndInstall` 才是核心代码，我们往下看。

> com.squareup.leakcanary.AndroidRefWatcherBuilder#buildAndInstall

```java
  public @NonNull RefWatcher buildAndInstall() {
    if (LeakCanaryInternals.installedRefWatcher != null) {
      throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
    }
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
      if (enableDisplayLeakActivity) {
        LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
      }
      if (watchActivities) {
        ActivityRefWatcher.install(context, refWatcher);
      }
      if (watchFragments) {
        FragmentRefWatcher.Helper.install(context, refWatcher);
      }
    }
    LeakCanaryInternals.installedRefWatcher = refWatcher;
    return refWatcher;
  }
```

buildAndInstall 这个方法只让调用一次。下面的 3 个if 才是核心。

### com.squareup.leakcanary.internal.LeakCanaryInternals#setEnabledAsync

先看第一个：

```java
LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
```

这行代码的作用与桌面启动图标有关系。我们先看依赖库的 AndroidManifest.xml 文件：

```xml
        <activity
            android:name="com.squareup.leakcanary.internal.DisplayLeakActivity"
            android:enabled="false"
            android:icon="@mipmap/leak_canary_icon"
            android:label="@string/leak_canary_display_activity_label"
            android:process=":leakcanary"
            android:taskAffinity="com.squareup.leakcanary.${applicationId}"
            android:theme="@style/leak_canary_LeakCanary.Base" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
```

可以看到，这个依赖库里面也设置了一个 LAUNCHER 页，加上我们的 App 也有一个，那么就有两个了启动页了。但是注意这里 activity 的 enable 属性配置的是 false，所以这个启动页图标一开始不会显示，只有调用了 install 方法，执行了 `setEnabledAsync` 方法才会显示。里面的逻辑较简单就部分析了，注意一下这个方法是异步的，开了一个线程。



### com.squareup.leakcanary.ActivityRefWatcher#install

第二个 if，这里就是使用 `ActivityLifecycleCallbacks`。

> com.squareup.leakcanary.ActivityRefWatcher#install

```java
  public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {
    Application application = (Application) context.getApplicationContext();
    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);

    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);
  }
```

其实就是调用了 Application 的 registerActivityLifecycleCallbacks 方法。核心内容在 ActivityRefWatcher 这个类中。

> com.squareup.leakcanary.ActivityRefWatcher

```java
  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
      new ActivityLifecycleCallbacksAdapter() {
        @Override public void onActivityDestroyed(Activity activity) {
          refWatcher.watch(activity);
        }
      };
```

它有一个成员变量，叫 lifecycleCallbacks，也是上一个方法用到的。ActivityLifecycleCallbacksAdapter 是 

ActivityLifecycleCallbacks 的一个空实现，里面啥都没做，只是为了减少无关方法的复写。

所以 ActivityRefWatcher 的作用就是：创建了一个 ActivityLifecycleCallbacks 监听，在 onActivityDestroyed 回调里面，调用了 `refWatcher.watch(activity);` 这行代码。

最终，还是到了 `com.squareup.leakcanary.RefWatcher#watch(java.lang.Object)` 这个方法，如果你对前面的代码还有影响，可以发现，我们监控 Service 等对象，也是调用的这个方法。

所以，看了这么多，本质上还是调用了 `com.squareup.leakcanary.RefWatcher#watch(java.lang.Object)`。只不过一个是在统一的地方调用，一个是手动的一处一处的调用。



### com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#install

这个方法就是实现了 Fragment 的监控。看看它是如何实现的。

> com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#install

```java
    public static void install(Context context, RefWatcher refWatcher) {
      List<FragmentRefWatcher> fragmentRefWatchers = new ArrayList<>();

      if (SDK_INT >= O) {
        fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher));
      }

      try {
        Class<?> fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);
        Constructor<?> constructor =
            fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);
        FragmentRefWatcher supportFragmentRefWatcher =
            (FragmentRefWatcher) constructor.newInstance(refWatcher);
        fragmentRefWatchers.add(supportFragmentRefWatcher);
      } catch (Exception ignored) {
      }

      if (fragmentRefWatchers.size() == 0) {
        return;
      }

      Helper helper = new Helper(fragmentRefWatchers);

      Application application = (Application) context.getApplicationContext();
      application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);
    }
```

这个方法里面先是创建了两个 `FragmentRefWatcher` 对象，一个是 `AndroidOFragmentRefWatcher`，一个是 `SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME`。

最后，又注册了一个  ActivityLifecycleCallbacks，注意这里的 ActivityLifecycleCallbacks 是 Helper 自己的，看看它做了什么：

> com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#activityLifecycleCallbacks

```java
    private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =
        new ActivityLifecycleCallbacksAdapter() {
          @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
            for (FragmentRefWatcher watcher : fragmentRefWatchers) {
              watcher.watchFragments(activity);
            }
          }
        };
```

其实就是在 Activity 创建完成之后，调用了 FragmentRefWatcher 的方法。上面我们分析过，FragmentRefWatcher  有两个实例对象。



### AndroidOFragmentRefWatcher

我们先分析 `AndroidOFragmentRefWatcher` 做了什么。

> com.squareup.leakcanary.internal.AndroidOFragmentRefWatcher#watchFragments

```java
  @Override public void watchFragments(Activity activity) {
    FragmentManager fragmentManager = activity.getFragmentManager();
    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);
  }
```

这里出现了一个我没见过的方法，没想到 Fragment 也能像 Activity 一样注册监听，学到了。同理，我们应该也能猜到，这个监听里面做了什么。

> com.squareup.leakcanary.internal.AndroidOFragmentRefWatcher#fragmentLifecycleCallbacks

```java
  private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =
      new FragmentManager.FragmentLifecycleCallbacks() {

        @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {
          View view = fragment.getView();
          if (view != null) {
            refWatcher.watch(view);
          }
        }

        @Override
        public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) {
          refWatcher.watch(fragment);
        }
      };
```

这里监控了两个对象，一个是 Fragment 本身，一个是 Fragment 的 rootView。



### SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME

还有一个 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME。

上面的逻辑分析中，如果你看的仔细的话，会发现我们获取 FragmentManager 实例的时候，使用的是 getFragmentManager 方法，而不是 getSupportFragmentManager 方法。就是说，AndroidOFragmentRefWatcher 是针对原生的 Fragment 的，而 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME 就应该是针对 support 包里面的 Fragment 的。

还有一个要理解的地方就是，在创建 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME 实例的时候，使用了反射，这是因为这个 Fragment 需要添加额外的依赖`leakcanary-support-fragment`，所以才使用的反射。

我们还是看看代码吧：

> com.squareup.leakcanary.internal.SupportFragmentRefWatcher

```java
class SupportFragmentRefWatcher implements FragmentRefWatcher {
  private final RefWatcher refWatcher;

  SupportFragmentRefWatcher(RefWatcher refWatcher) {
    this.refWatcher = refWatcher;
  }

  private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =
      new FragmentManager.FragmentLifecycleCallbacks() {

        @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {
          View view = fragment.getView();
          if (view != null) {
            refWatcher.watch(view);
          }
        }

        @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) {
          refWatcher.watch(fragment);
        }
      };

  @Override public void watchFragments(Activity activity) {
    if (activity instanceof FragmentActivity) {
      FragmentManager supportFragmentManager =
          ((FragmentActivity) activity).getSupportFragmentManager();
      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);
    }
  }
}
```

与 AndroidOFragmentRefWatcher 的代码几乎是一样的。


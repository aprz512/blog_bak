---
title: 0027-栈的应用之四则表达式
date: 2019-9-4
tags: 算法-大话数据结构
categories: 大话数据结构
---

四则表达式大家应该都知道如何取计算，有个口诀：

> 先乘除，后加减，从左算到右，先括号内再括号外。

看下面的这个表达式：

```
9 + (3 - 1) * 3 + 10 / 2
```

这个表达式，让我们来算，非常的简单。但是让计算机来计算呢，就比较麻烦了。因为计算机不会口诀，它不知道应该先计算括号里面的。

那么如何才能让计算机计算四则表达式呢？在 20 世纪 50 年代，一个波兰逻辑学家（名字太长，就不打了）发明了一种后缀表达式（逆波兰表达式）。这种后缀表达式是一种全新的显示方式，非常巧妙的解决了程序实现四则运算的问题。

对于上面的那个四则表达式，它的后缀表达式如下：

```
四则表达式
9 + (3 - 1) * 3 + 10 / 2
后缀表达式：
9 3 1 - 3 * + 10 2 / +
```

之所以叫后缀表达式，是因为符号在要运算数字的后面出现。



## 后缀表达式的计算

有了后缀表达式，我们需要理解它是如何工作的，先来说一段规则：

> 从左到右遍历表达式的每个数字与符号，遇到数字就进栈，遇到符号，就出栈两个数字，然后进行运算，将运算的结果进栈，一直遍历完毕，最后栈内的就是计算结果。

看下面的这个例子：

```
后缀表达式：
9 3 1 - 3 * + 10 2 / +
```

1. 创建一个空栈，遍历表达式，前3个都是数字，直接进栈：

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-1.png?raw=true)

2. 接下来遇到了 “-”，从栈里面取两个运算数字，第一个是减数，第二个是被减数，即（3 - 1），然后将结果 2 进栈:

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-2.png?raw=true)

3. 接着是数字 3 进栈

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-3.png?raw=true)

4. 接着是遇到了 “*”，同样从栈里面取出两个数字，计算（2 * 3），将结果 6 放入栈中，然后，又遇到了 “+”，从栈里面取出两个数字，计算（9 + 6），将结果 15 放入栈中：

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-4.png?raw=true)

5. 接着是，10 与 2 进栈，然后是遇到 “/”，计算（10 / 2），将 5 进栈。最后遇到 “+”，计算 （15 + 5），将 20 进栈。20 就是计算结果。

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-5.png?raw=true)



## 中缀表达式转后缀表达式

前面我们说了，后缀表达式对于程序来说，很好描述，但是如果没有一个方法很容易的将中缀表达式转成后缀表达式的话，后缀表达式毫无意义。

所以这里介绍中缀表达式转后缀表达式的规则：

- 从左到右遍历中缀表达式
- 遇到数字直接输出
- 遇到左括号进栈
- 遇到右括号，需要将栈内元素出栈，直到左括号出栈
- 遇到符号需要对于栈顶元素
  - 如果栈为空，进栈
  - 如果栈顶为左括号，进栈
  - 将栈顶元素依次出栈，直到遇到比该符号的优先级低的符号。

还是上面的例子【9 + (3 - 1) * 3 + 10 / 2】，用图来描述一遍：

1. 初始化一个空栈，开始遍历，第一个是数字 9 ，直接输出，然后是符号 “+”，进栈

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-6.png?raw=true)

   此时表达式为：9

2. 左括号未配对，直接进栈，3直接输出，“-”进栈，1直接输出，遇到右括号需要将栈里面的元素输出，直到左括号出栈

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-7.png?raw=true)

   此时表达式为：9 3 1 - 

3. 遇到 “*” 号，比栈顶元素的优先级高，进栈，输出 3

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-8.png?raw=true)

   此时表达式为：9 3 1 - 3

4. 遇到 “+”号，将 “*”出栈，将“+”出栈，将这个“+”号进栈，输出表达式为 ：，然后是输出 10，将“/”进栈，

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-9.png?raw=true)

   此时表达式为：9 3 1 - 3 * + 10

5. 输出 “2”，将 “/”，“+” 出栈

   ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-10.png?raw=true)

   此时表达式为：9 3 1 - 3 * + 10 2 / +


---
title: 0022-进栈出栈变化形式
date: 2019-9-1
tags: 算法-大话数据结构
categories: 大话数据结构
mathjax: true
---

思考一个问题：有 [1, 2, 3, 4, ... ，n] 一共 n 个整数，他们按顺序入栈，问一共有多少种出栈顺序（提示：1 入栈之后可以立即出栈）？

首先，我们设f(n)代表序列个数为n的出栈序列种数。同时，**我们假定第一个出栈的序数是k**。

第一个出栈的序数k将1~ n的序列分成两个序列：

- 其中一个是1~ k-1，序列个数为k-1；
- 另外一个是k+1~n，序列个数是n-k。 

那么对于一个给定的值 k 来说，f(k) 就表示前 k 个数的出栈顺序，f(n-k) 就表示后 n-k 个数的出栈顺序。

f(n)的问题就等价于**序列个数为k-1的出栈序列种数乘以序列个数为n - k的出栈序列种数**，即选择k这个序数的出栈组合为f(k-1)×f(n-k)，又因为第一个出栈的数可以是 1 ~ n 中的任意一个数，所以 k 可以取值 1 ~ n。

所以：f(n) = f(0)f(n-1) + f(1)f(n-2) + ...... + f(n-1)f(0)

```
f(0) = 1;
f(1) = 1;
```

如果，我们知道卡特兰数，那么这个公式可以转换为 $C^n_{2n}-C^{n+1}_{2n}$  。



可以看出最后转换成了排列组合公式，那么下面我们从排列组合的角度来思考一下这个问题。

我们先不管数的顺序是怎么样的，对于每一个数来说，总是要先入栈一次，然后再出栈一次。这里就假设入栈记为1，出栈记为0，那么就会产生一个 2n 个数的序列。这个序列由 n 个 1 与 n 个 0 组成。

使用排列组合的思想，在 2n 个位置里面选 n 个位置放入 1，其余的位置放入 0，一共有 $C^n_{2n}$ 种可能。

然后再思考一下，按照上面的排列方式，有一些序列是不符合要求的，比如 `0001...` 这种序列，因为 0 表示出栈，前面都没有入栈，哪里来的出栈呢？

所以我们需要找出在某个位置上，它前面的0的个数大于1的个数的所有序列。

我们假设在某个位置上（只能是奇数位置，不可能是偶数位置），0的个数刚好比1的个数**多一个**，设这个位置为 2m+1。

那么，这个位置前就有 m+1 个 0 和 m 个 1。后面有 n-m-1 个 0， n -m 个 1。

这里我们要做一个骚操作：

将  2m+1 位置后面的 0 与 1 互换，则该位置后面就变成了 n-m-1 个 1， n -m 个 0。所以整个序列变成了由 n+1 个 0， n-1 个 1 组成的序列。

我们将所有不符合要求的集合记作 B。

将由 n+1 个 0， n-1 个 1 组成的序列集合记作 A，A 的个数为 $C^{n+1}_{2n}%$。

B 集合中的每一个元素都对应着 A 中的一个元素。

则 A 集合包含 B 集合。

再反过来思考，任何一个由 n+1 个 0 和 n-1 个 1 组成的 2n 个数的序列，由于 0 的个数比 1 的个数多 2 个，2n为偶数，故必在某一个奇数位上 0 的个数刚好比 1 的个数多一个。同样在后面部分0和1互换，就成为了由 n 个 0 和 n 个 1 组成的 2n 个数的序列，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。

同样的，转换为集合来思考，即集合 B 包含集合 A。

最终，我们得到，集合A = 集合B。

所以，不符合要求的集合数为 $C^{n+1}_{2n}$。

最后得到  $C^n_{2n}-C^{n+1}_{2n}$  。








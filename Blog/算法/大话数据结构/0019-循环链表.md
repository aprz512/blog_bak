---
title: 0019-循环链表
date: 2019-8-27
tags: 算法-大话数据结构
categories: 大话数据结构
---

前面我们说的链表都是单链表，因为链表中的节点只储存了指向后一个节点的指针，所以我们无法向前遍历，只能向后遍历。

如果我们想要遍历前面的节点，那么该怎么做呢？原来的单链表结构是无法做到了，所以需要改进一下。

第一中改进方案就是这一章需要讲的，循环链表。

顾名思义，就是将链表的头和尾连起来，串成一个圆环，就是循环链表了。

同样是只能向后遍历，因为头和尾连起来了，所以最后总能遍历到前面的节点。有点不撞南墙不回头的意思。

虽然只是将头与尾连起来了，但是在使用这个数据结构的时候，还是有几个需要注意的地方。



## 循环链表的初始化

为了与单链表保持一致，循环链表也有一个头节点，但是在初始化这个头节点的时候，需要注意一下，因为刚开始的链表是没有数据的，所以这个时候头节点需要指向自己，如下图：

![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-13-3.png?raw=true)

当有数据的时候，循环链表如下图：

![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-13-4.png?raw=true)

可以看出，其实这种循环链表与单链表的差别不大，只不过循环链表的遍历条件变成了：`node.next != headNode`。

我们想访问一个节点的时候，时间复杂度仍然为 O(n).

有些时候，我们需要访问到链表的最后一个元素，按照上面的循环链表的结构，我们需要 O(n) 的时间，那么有没有快捷一点的方法呢？

显然是有点，比如说我们加一个尾指针，指向最后一个节点，这样就可以以 O(1) 的时间访问尾节点了。再仔细想一下，有了尾指针，头指针还需要吗？

因为是循环链表，所以尾指针指向的就是头节点，所以可以不需要头指针了。如下图：

![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-13-5.png?raw=true)

举一个尾指针的用处，合并两个链表，如下图：

![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-13-6.png?raw=true)

要想将它们合并，还是很简单的，先理清思路：

- 将 A 链表的头尾节点引用断开（由于断开后就找不到了，所以需要保存一下头节点的引用）
- 将 A 链表的尾指针指向 B 链表的第一个节点
- 将 B 链表的尾指针指向 A 链表的第一个节点

代码如下：

```java
Node temp = rearA.next;
rearA.next = rearB.next.next;
// 因为 java 会自动释放节点，所以就没写
// 可以加上
// Node headB = rearB.next;
// free(headB);
rearB.next = temp;
```

有了尾节点之后，代码会简单很多，**因为合并链表涉及到头与尾两个节点**，所以使用尾节点比较方便。
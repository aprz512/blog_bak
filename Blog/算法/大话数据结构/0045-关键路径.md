---
title: 0045-关键路径
date: 2019-9-22
tags: 算法-大话数据结构
categories: 大话数据结构
---



## 关键路径

关键路径是拓扑排序的一种进阶使用。

当我们将一个工程的各个流程转换为一张有向图时，我们可以使用拓扑排序来判断工程是否能够顺利完成（有没有环）。

但是如果我们想知道这个工程能够顺利完成，那么就需要知道这个有向图的**关键路径**了。

什么是关键路径呢？就是在一个有向图中，从起点到终点，肯定会有不止一条路，关键路径就是**最长的那条路**。



### 如何计算关键路径

我们先来看一个非常简单的图：

![](critical_path1.png)

显然，图中的关键路径是 A -> B -> D。

这个对人类的大脑来说，非常简单就能计算出来，但是如果图变得复杂，我们就无法一眼看出来了。



这个关键路径有3个点，我们将这个图压扁，如下：

![](critical_path2.png)

我们假设图上边的权重，代表的是时间（单位为小时）。

对于 A -> C -> D 这条**不关键**的路径，它由两条边构成：

```
A -> C
C -> D
```

如果我们一开始就进行 A -> C 的工作，花 5 个小时完成。

然后继续进行 C -> D 的工作，花 9 个小时完成。

这个时候，工程仍然处于未完成状态，因为 B -> D 这条线还处于进行状态。

所以，我们也可以这样，我们一开始不做 A -> C 的工作，我们等 （3 + 27 - 9 - 5） 个小时，在开始 A -> C 的工作。

你就会发现，**不关键的路径的执行时间是可以浮动的**。

对于上面的例子，A -> C 的浮动范围为 (0, 16)， C -> D 的浮动范围为 (5, 21)。

> 就不要太在意边界条件了



### 算法思想

先来四个定义：

>  前两个针对顶点，后两个针对边

**事件最早开始时间**：顶点Vi最早发生的时间。

**事件最晚开始时间**：顶点Vi最晚发生的时间，超出则会延误整个工期。

**活动的最早开始时间**：边Eg最早发生时间。

**活动的最晚开始时间**：边Eg最晚发生时间。不推迟工期的最晚开工时间。

我们很难直接计算出边的最早最晚开始时间，但是对于每个顶点来说，可以比较简单的计算出。

有了每个顶点的最早最晚发生时间，我们就可以计算出边的最早最晚发生时间，从而得出关键路径。



### 算法实现

首先，我们仍然使用 拓扑排序 计算出一个顶点序列，不过，我们在做拓扑排序的时候，还可以顺便做一件事情，就是计算出每个定点的最早发生时间。

计算公式如下：

etv[k] = max{etv[i] + len(vi, vk)}

这个公式的意思：

> 顶点 k 的最早发生时间 = 顶点 i 的最早发生时间 +  i -> k 这条边的值。
>
> i 为与 k 相连的所有顶点。
>
> 顶点 i 为弧头，k 是弧尾。



我们得到了 拓扑序列 与 所有顶点的最早发生时间，然后就可以获取所有顶点的最晚发生时间了。

我们将**拓扑序列倒序遍历**，做如下计算：

ltv[k] = min{ltv[j] - len(vk, vj)}

这个表达式，与上面的差不多，意思也差不多，不过这里是做减法。

还有一个需要注意的地方，就是 顶点 k 是弧头，顶点 j 是弧尾，与上面是相反的。

这样，我们就求的了各个顶点的最晚发生时间。



知道了最早最晚发生时间，就可以求边的最早最晚发生时间，从而得到关键路径。

```c++
for (i=0;i<g.numVextexs;i++)
{
    if (g.adjList[i].fitstedge)
    {
        e = g.adjList[i].fitstedge;
        while(e)
        {
            int eIdx = e->idx;
            //活动（i->eIdx）最早开始时间：事件（顶点） i最早开始时间
            ete = g_etv[i];
            //活动（i->eIdx）最迟开始时间：事件（顶点） eIdx 最迟开始时间 减去 活动持续时间
            lte = g_ltv[eIdx] - e->weigh; 
            if (ete == lte)
            {
                printf("(%c - %c)->",g_init_vexs[i],g_init_vexs[eIdx]);
            }
            e= e->next;
        }
    }
}
```

这个的循环，就是遍历每个顶点的邻接边，求各个边的最早最晚发生时间。
## Kruskal 算法

前面的 Prim 算法是以顶点为主要思考方向，使用的是邻接矩阵。

而 Kruskal 算法是以边为主要思考方向，它使用的是边集数组。



Kruskal 算法，比较好描述：

1. 将边按权值升序排序；
2. 选出权值最小的边，记录下这条边的两个顶点，如果这两个顶点与集合中已有的顶点没有构成闭合回路，则将则两个顶点添加到集合中，否则排除这条边；
3. 重复步骤2，直到所有顶点都加入最小生成树中；



用小人走迷宫举例就是：

> 让小人将迷宫所有的路都跑一遍，按每条路的长度排个序。
>
> 首先选取最短的路，将这条路画到小本本上。
>
> 然后再选取第二短的路，判断这条路是否与小本本上的路产生了闭合回路，如果没有，则画到小本本上，如果有，则排除这条路，这样不断地循环所有的路。

![img](https://img-blog.csdnimg.cn/20190509001625839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtMjAxNzA4NjcyMzg=,size_16,color_FFFFFF,t_70)

将图的边按权值排序，每个顶点放在单独的集合里：

- 选出权值最小的边（0，2）加入到最小生成树中，顶点0和2不在同一集合，没产生回路。合并顶点0和2所在的集合。

- 选出权值最小的边（3，5）加入到最小生成树中，顶点3和5不在同一集合，没产生回路。合并顶点3和5所在的集合。

- 选出权值最小的边（1，4）加入到最小生成树中，顶点1和4不在同一集合，没产生回路。合并顶点1和4所在的集合。

- 选出权值最小的边（2，5）加入到最小生成树中，顶点2和5不在同一集合，没产生回路。合并顶点2和5所在的集合。

- 选出权值最小的边（0，3）加入到最小生成树中，顶点0和3在同一集合中，产生回路，故放弃这条边。再选出权值最小的边（1，2）加入到最小生成树中，顶点1和2不在同一集合，没产生回路。合并顶点1和2所在的集合。

至此所有顶点都在同一个集合中，一颗最小生成树就构造完成。

算法中的难点，就是如何判断顶点，是否产生了回路！！！

可以这样做：

我们定义一个数组 parent[]，x = parent[y]，我们记作 x -> y。

当有一条边 [i - j] 到来时，我们让 i = parent[j]。

当下一条边 [i - n] 到来时，我们让 i = parent[n]。

我们就有了这样的关系图：n -> i <- j。

n 与 j 的 parent 都是 i。这样如果以后有一条边包含了 n 与 j，我们就知道，这条边肯定形成闭合回路了。

说了这么多，其实就是给这些边都加一个方向，从边两个顶点出发，都走到了同一个终点，那么就是形成回路了。

从某个顶点出发，走到最终点的代码逻辑如下：

```java
int find(int[] parent, int f) {
    while (parent[f] >0) {
        f = parent[f];
    }
    return f;
}
```






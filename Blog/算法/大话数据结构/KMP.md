KMP 算法的改进。

假设，主串为 S，匹配串为 P。

比较到了，S[i] 与 P[j] 的位置，发现这两个字符并不显相等。

所以需要比较，S[i] 与 P[next[j]]，如果 P[next[j]] 与 P[j] 相等的话，那么就白比较了，因为它们肯定不相等。

所以，我们需要避免这样的情况。当匹配串为 aaaaaaab 这样的字符串时，会容易出现这种情况。

如何避免呢？在构建 next 数组的时候，需要额外判断一下：

```java
// i 就是 next[j] 的值，所以需要判断
if (p[i] != p[j]) {
	next[j] = i;
} else {
    // 这里将 i 所在位置的 next 值，赋值给 j 所在位置，因为前后缀相等，赋值是合理的
    // 减少了匹配串回溯的步骤
    next[j] = next[i];
}
```





 
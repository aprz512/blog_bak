## 面试中的算法



当时间复杂度为 O(1) 时，则无法再优化，需要从空间方面想办法。

同样的，当空间复杂度为 O(1)时，只能从算法时间方面想办法（需出奇兵）。



### 如何判断链表中是否有环？

最容易想到的就是将每个节点记录下来，然后判断判断是否出现过即可。这样的话空间复杂度为0(n)，如果想要空间复杂度为 O(1)，该如何做呢？

可以将链表想象成一条路，链表有环，即路也有环。想象一下操场。

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574176264655&di=d230987c76ffce6b2f6c2e6c29da9eaa&imgtype=0&src=http%3A%2F%2Fimgs.focus.cn%2Fupload%2Fnews%2F7709%2Fb_77082888.jpg)

操场的圆圈即链表的环。

判断一个链表有没有环，可以这样来。

我们小时候不是会进程做这样的题目么： 两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过 。这是因为跑的快的已经比跑的慢的多跑了一圈了，所以，我们可以利用这个现象来解决这个问题。

这个解决办法叫做快慢指针法。具体过程如下：

首先创建两个指针p1和p2（在Java里就是两个对象引用），让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。

好的，解决方法理解了，那么下面出一些扩展内容：

#### 如何求出环的长度？

如果你能想出快慢指针法，那么这个问题也不难。如果你真的理解了快慢指针法，这个问题也不难。

就是让指针继续跑，再次相遇时，快指针就比慢指针多跑了一圈了，这个长度就是环的长度。我们只需要记下循环次数就好了。



#### 如何找到入环点？

这个问题就有点难度了，涉及到数学知识。看下面的图：

![](linklist_ring.png)
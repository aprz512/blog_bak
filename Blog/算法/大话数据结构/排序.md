---
title: 0052-几种排序算法
index_img: /cover/22.jpg
banner_img: /cover/top.jpg
date: 2019-9-22
tags: 算法-大话数据结构
categories: 大话数据结构
---



## 冒泡排序

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574071390673&di=ba2aabca513398477433f20938c0e1cc&imgtype=jpg&src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170709%2F75b2287703174baa856f13ff062ad0f3_th.jpg)

假设我们不是对序列进行排序，而是对角斗士进行武力排名，那么该怎么设立一个规则呢？

我们给角斗士每人分配一个令牌，令牌的编号对应着排名，从 1 到 n，刚开始肯定是随机分配一个令牌。

然后角斗士可以发起挑战，但是只能挑战排名比自己高1位的对手，比如编号为 14的，只能挑战编号为13的对手，如果挑战成功之后，互换令牌。

这样，经过一段时间之后，角斗士手里的令牌不再变化了，那么手里令牌为1的，就是武力最高的了。

这就是一个冒泡排序了，能力更出众的，总是会往上冒。



## 选择排序

选择排序虽然也可以用角斗士的例子，但是这样不免重复，会导致记忆混乱。

选择排序着重于选择，每一次的选择结果都会导致序列变化。

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574073009920&di=7eb6589c7d79ca4edaee46a995c83d11&imgtype=0&src=http%3A%2F%2Fpic.962.net%2Fup%2F2018-9%2F15366576267342512.jpg)

假设你是一个农村里的孩子，一天你砍了很多竹子用来喂竹鼠，但是在喂之前你突然想给竹子按长度排一个序，然后再砍了喂竹鼠。那么该怎么排呢？

可以这样，先扫一眼所有的竹子，找到最长的，放到第一位，这样最长的就找到了，将这个最长的拿到一边。

重复上面的步骤，就排好序了。

所谓选择，就是每次都选择一个自己需要的。

选择排序比起冒泡排序少了很多交换动作，所以要稍微快点。



## 插入排序

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574073480251&di=cfa51463944838874a03a931d7f4e25a&imgtype=0&src=http%3A%2F%2Fa4.att.hudong.com%2F64%2F93%2F19300001024098134717935829117.jpg)

插入排序有一个最形象的例子了，每个人都玩过，就是扑克牌。

回想一下，你斗地主的时候，一张一张的起牌的时候，是不是每次都是插入一张牌到手里的牌里面。

比如，你的手里有一张 3，一张 5，这个时候来了一张 4，你肯定是将 4 插入到 3 与 5 中间。

因为你手里的牌本来就是有序的，所以插入也非常快。

插入排序不稳定，如果本来是有序的，最快可以为 o(n)，最慢为 o(n*n)。



## 希尔排序

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574075185473&di=e0ee7af3c73da1adb0132ea852e1313f&imgtype=0&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2Ffc43c32d0d7b7f9e17bb562f09de8edecc37f80b.jpg) 



前面说过，插入排序在序列有序的情况下，速度非常快，那么可不可以先让序列变为基本有序，然后再排序呢？

说明一下，啥叫基本有序，基本有序就是小的基本在前面，大的基本在后面，不大不小的基本在中间。

比如一个序列，{9， 1， 5， 8， 3， 7， 4， 6 ，2}，它是一个无序序列。

想一下，怎么将它变成一个基本有序序列？

我们将这个序列，按照镂空的方式分为3段，如下：

第一段：{o，x，x，o，x，x，o，x ，x}，得到 {9，8，4}

第二段：{x，o，x，x，o，x， x，o ，x}，得到 {1，3，6}

第三段：{x，x，o， x，x，o，x， x ，o}，得到 {5，7，2}

为啥要这样分呢？因为这样分了之后，每一段都保留了整个序列的部分特征，对这些子序列进行排序之后，整个序列就会基本有序。

比如，我们使用插入排序，将上面的3个子序列排序后：

{4，8，9}

{1，3，6}

{2，5，7}

合并之后，就会得到{4，1，2，8，3，5，9，6，7}，虽然还不是有序的，但是比起原来的序列，已经算得上的基本有序的，然后我们重复上面的步骤，再次将整个序列分解，但是间隔要慢慢变小，直到为0。

为 0 时，就是最后一次比较，就是对整个序列进行一次插入排序，比较完之后，序列就是有序的了。

希尔排序的时间复杂度在 ${o(n^{\frac{3}2})}$，虽然它的代码里面有3个循环。



## 堆排序

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574075256315&di=7523894d6b6d242d9e8f4bd360f5aa1a&imgtype=0&src=http%3A%2F%2Fimg.juimg.com%2Ftuku%2Fyulantu%2F140812%2F330709-140Q211040899.jpg)



堆是一个完全二叉树。

在排序算法中，我们使用数组来表示这个完全二叉树，如下：

![](https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180110173213144-507404208.png)

上图是一个大顶堆，大顶堆就是最大的在根上。对应的还有小顶堆。

看图中每个节点的索引关系：

>一个节点的索引为 i，其左孩子节点的索引为 2*i + 1，右孩子节点的索引为 2\* i + 2.
>
>当然这个关系不是固定的，如果不在0位置储存元素，那么关系就不一样了。

对于一个无序序列，刚开始的堆肯定是不满足条件的，需要调整这个堆，如何调整呢？很简单，只需要对非叶子节点，做如下处理就好了：

> 比较它的左右孩子，找到更大的孩子，然后与自己比较，如果孩子大，则交换。

注意，要对每个非叶子节点处理，遍历的时候，要从索引值由大到小开始，不然的话，小的（就是最上面的）先换了也没用。好的，我们使用内在化来强化记忆一下这个过程：

![](https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/heapSort.gif?raw=true)

这里有一个动图，只看它的前半部分。

我们将每个节点当作一个角斗士，对于最下面一层的角斗士，他们下面已经没有人了，所以没必要决斗。对于其他角斗士，则需要从3个角斗士中选一个，让最厉害的角斗士站在顶端。如下：

![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/heap.png?raw=true)

对每个非最底层的角斗士（从下往上）都这样来一遍，这样处于最顶端的就是最厉害的角斗士了。这个和我们常见的两两对战不一样，而是三三对战。

如此，我们的大顶堆就构建好了。构建好了然后呢，这个玩意怎么帮助我们排序呢？

假设，国王让你选出10个最厉害的角斗士，你按照上面的三三对战方式选出了最厉害的一个，然后该怎么办？将最厉害的择出来，然后按照同样的方式再一次选一个吗？这样也可以，但是就浪费了第一次比较的结果（时间复杂度为o(n*n)的都是这样，没有好好利用前一次比较的结果）。

那么应该如何利用前一次的比较结果呢？只需要找到完全二叉树里面，叶子节点最右边的一个（索引值最大的一个），将它与根节点交换，然后让根节点不断的下沉就好了。

所以，我们让序号最大的角斗士与序号最小的角斗士交换位置，再将最后一个位置去掉（它已经是最厉害的了）。

交换之后，让序号最小的角斗士与他下面的两人比较，谁最厉害就与谁交换位置。这里假设交换的左边的孩子位置，那么它应该下沉到左边孩子位置。

下沉之后，再让他与两个孩子比较，不断的重复这个过程，直到位置不再改变，这样，根上的就是第二厉害的角斗士了，而且依然是一个大顶堆。



堆排序的时间复杂度为 O(n*logn)，因为二叉树的高度为 logn，空间复杂度 o(1)，只需要一个用来储存临时数据的交换单元，还是非常不错的。

堆排序是一个不稳定的算法，因为交换不是相邻交换，而是跳跃式交换。



## 归并排序

![]( https://a.zdmimg.com/201909/27/5d8d6d7b953bb6313.jpg_fo742.jpg )

归并排序使用了分治的思想。

假如你是皇帝，你要选出全国最美的十个少女，那么应该怎么做呢？

你需要将命令传递到丞相，丞相将命令下发到各个州，各个州再传递到各个郡，各个郡再传递到各个县。

然后由县令统计出当地的少女并排好名次，再交给所属的太守，太守负责汇总所管辖的各个县，然后排出所有名次，再上传给刺史。然后刺史汇总所有管辖的郡，排好名次，上传给丞相，丞相汇总各个州的名词，在交给皇帝，就搞定了。

先看看归并排序的动图吧：

![](https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326201207440-689679432.gif)



这个很容易理解：

就是将一个 n 长的序列，分解为n个1长度序列，然后两两比较，合成 n/2 个 2 长度的序列，再两两合并，直到序列只有一个。

归并排序是相邻的比较，所以是稳定的排序。它的时间复杂度为 O(n*logn)，但是空间负责度为 O(n)。将两个数组合并成一个数组的时候需要额外的储存空间。



## 快速排序

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574163780407&di=220f5a174e686c27c818a2fd5f03e0e1&imgtype=0&src=http%3A%2F%2Fimgqn.koudaitong.com%2Fupload_files%2F2015%2F02%2F05%2FFl6VuwWfHxhPtmRW54B2r_YElPEc.jpg%2521730x0.jpg)



比如，你在逛一个超市，买了各种零食与家用品，全部放在了堆在了背包里面。

回家后，你想按照价值给它们排个序，你准备如何做呢？

可以这样做，随便从包里选一个出来作为参照物，然后将比这个参照物价值小的放到左边，将比这个参照物价值大的放到右边。这样，参照物的位置就固定了，然后再堆左右两边做同样的操作，直到左右两边不可分隔。这样就排好序了。

这个就是快速排序。

看个图加深一下印象：

 ![img](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1) 



快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：

> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。



## 参考文档

[JS-Sorting-Algorithm](https://github.com/hustcc/JS-Sorting-Algorithm)

[十大经典排序算法动画与解析，看我就够了！（配代码完全版）]( https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg )


---
title: 0040-最小生成树之Prim算法
index_img: /cover/22.jpg
banner_img: /cover/top.jpg
date: 2019-9-22
tags: 算法-大话数据结构
categories: 大话数据结构
---



## 普里姆算法

算法思想：

新建一个空的集合V，新建一个空的集合E。

在无向图中随便取一个顶点作为起点，加入V，然后遍历包含这个顶点的所有边，找到最短的边，加入E，将这条边的另一个顶点也加入V，这样我们就有了两个顶点。

再对V中的每一个元素，重复做上面的操作，这个集合就会不断的增长，直到包含所有顶点为止。这样 E 的集合就是最小生成树。

下面对算法的图例描述：

| 图例                                                         | 说明                                                         | 不可选 | 可选       | 已选（Vnew）        |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ | ---------- | ------------------- |
| ![img](https://pic002.cnblogs.com/images/2012/426620/2012073015154494.png) | 此为原始的加权连通图。每条边一侧的数字代表其权值。           | -      | -          | -                   |
| ![img](https://pic002.cnblogs.com/images/2012/426620/2012073015175038.png) | 顶点**D**被任意选为起始点。顶点**A**、**B**、**E**和**F**通过单条边与**D**相连。**A**是距离**D**最近的顶点，因此将**A**及对应边**AD**以高亮表示。 | C, G   | A, B, E, F | D                   |
| ![img](https://pic002.cnblogs.com/images/2012/426620/2012073016090032.png) | 下一个顶点为距离**D**或**A**最近的顶点。**B**距**D**为9，距**A**为7，**E**为15，**F**为6。因此，**F**距**D**或**A**最近，因此将顶点**F**与相应边**DF**以高亮表示。 | C, G   | B, E, F    | A, D                |
| ![img](https://pic002.cnblogs.com/images/2012/426620/2012073016130394.png) | 算法继续重复上面的步骤。距离**A**为7的顶点**B**被高亮表示。  | C      | B, E, G    | A, D, F             |
| ![img](https://pic002.cnblogs.com/images/2012/426620/2012073016143177.png) | 在当前情况下，可以在**C**、**E**与**G**间进行选择。**C**距**B**为8，**E**距**B**为7，**G**距**F**为11。**E**最近，因此将顶点**E**与相应边**BE**高亮表示。 | 无     | C, E, G    | A, D, F, B          |
| ![img](https://pic002.cnblogs.com/images/2012/426620/2012073016154616.png) | 这里，可供选择的顶点只有**C**和**G**。**C**距**E**为5，**G**距**E**为9，故选取**C**，并与边**EC**一同高亮表示。 | 无     | C, G       | A, D, F, B, E       |
| ![img](https://pic002.cnblogs.com/images/2012/426620/2012073016114494.png) | 顶点**G**是唯一剩下的顶点，它距**F**为11，距**E**为9，**E**最近，故高亮表示**G**及相应边**EG**。 | 无     | G          | A, D, F, B, E, C    |
| ![img](https://pic002.cnblogs.com/images/2012/426620/2012073016100874.png) | 现在，所有顶点均已被选取，图中绿色部分即为连通图的最小生成树。在此例中，最小生成树的权值之和为39。 | 无     | 无         | A, D, F, B, E, C, G |

 

我们举一个走迷宫的例子，来比喻一下这个过程：

首先，有一个小人进入迷宫起点。

假设这个点有x个岔路，那么我们让这个小人将每条岔路都走一遍，用一个小本本将每条路的长短记录下来。

选取最短的路（将这条路圈起来），沿着这条路走到终点。

在假设这个点有y个岔路，那么我们让这个小人将每条岔路都走一遍，但是这次，我们只记录最短的一条到小本本上，然后选取小本本中记录的最短的（除去圈起来的），沿着这条路走到终点。

就这样不断的重复，直到所有点都走完。



要实现这个算法，我们需要一个**邻接矩阵**。

算法：

```c
//Prim算法生成最小生成树
void MiniSpanTree_prim(MGraph G)
{
    int min, i, j, k;
    int adjvex[MAXVEX];
    int lowcost[MAXVEX];
    lowcost[0] = 0;
    adjvex[0] = 0;
    
    // 我们先让lowcost[i]表示各个顶点i与第0个顶点之间的权值
    // 邻接矩阵中，没有相连的两个点，我们记为最大值
    for (i = 1; i < G.numVertexes;i++)
    {
        lowcost[i] = G.arc[0][i];
        adjvex[i] = 0; 
    }

    for (i = 1; i < G.numVertexes;i++)
    {
        min = INFINITY;
        j = 1;
        k = 0;
        
        // 找到 lowcost 中的最小值，即为与已有集合中的某个点相距最近的点
        // 我们以第一次循环举例，那么，这个就寻找的是距离顶点 0 最近的顶点 k
        while (j<G.numVertexes)
        {
            if (lowcost[j]!=0&&lowcost[j]<min)
            {
                min = lowcost[j];
                // 将这个点记录下来
                k = j;
            }
            j++;
        }
        
        // adjvex[k] 的意义，下面有讲解
        printf("(%d,%d)", adjvex[k], k);
        lowcost[k] = 0;


        // 寻找距离顶点k最近的点
        for (j = 1; j < G.numVertexes;j++)
        {
            if (lowcost[j] != 0 && G.arc[k][j]<lowcost[j])    
            {
                // 找到之后，更新 lowcost[j]
                // 这样 lowcost 就包含了距离集合V中所有顶点最近的顶点
                lowcost[j] = G.arc[k][j];
                // 更新 adjvex[j] ，adjvex[j] 表示距离j最近的是顶点k
                adjvex[j] = k;
            }
        }
    }
}

```



显然，该算法的时间复杂度为 O(n*n)。



参考文档：

https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html

---
title: 0032-KMP算法
index_img: /cover/12.jpg
banner_img: /cover/top.jpg
date: 2019-10-12
tags: 算法-大话数据结构
categories: 大话数据结构
---

KMP 算法并不是从一个全新的角度来思考字符串如何匹配会更快，它仍然是一个一个的比较两个字符串是否相等，但是它去除了暴力比较过程中一些无用的比较过程。

那我们自己举例，假设让你取寻找一个大的字符串中，是否有某一个特定的字串，我们也是从头开始寻找，这符合人的认知，算法也是人写出来的，所以这个思路是不会变的。

KMP 算法之所以高效，是因为它做了很多改进。我们一点一点来说明。

> 下面的内容
>
> 主串代表前面例子中的源码
>
> 子串代表我们需要搜索的字符串
>
> 忽略主串与字串之间的空格，这个是为了更好看

假设，我有这样的一个主串[aaa aaa aaa b]，和子串[aaa aaa aab]，它们看起来极为相似。如果让我们来判断是否有匹配的，我们应该一眼就能看出来，确实是有匹配的，主串截取[1, n]，就是与子串匹配的。

注意上面，我的说话，是**一眼就看出来的**，虽然我们大脑运作的很快，但是在你思考事情的时候，你应该知道你想了哪些步骤，与 O(n) 的考量一样，我们不关心你思考的速度，只关心你思考了几个步骤。

我想你一定没有傻乎乎的去一个一个去匹配，这需要归功于这个子串很简单，简单到我们能记住，所以我们才不会去一个一个的对着子串去和主串匹配。

那么这个时候，我们的大脑究竟做了什么呢？你可以先自己仔细想一想！

下面，我们再举一个例子：

假设，我有这样的一个主串[ababbababa]，和子串[ababa]。

我们先不考虑算法，而是用我们的脑子来找出主串里面是否包含子串。当我们匹配到第5个字符的时候，发现不一样了，这个时候我们该怎么做呢？？？

一般人的做法是，回到主串的第二个字符，再次比较字串。这种做法是什么？暴力匹配。是效率很低的！！！那么应该怎么做呢？

我们观察一下我们已经匹配过的串[abab]，发现什么没有，这个串是对称的（**这里的对称是 ab ab 这样的对称，不是镜像对称**）。那么对称能怎么样呢？

![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kmp_3.png?raw=true)

上面的图中说的很清楚了，有了对称性，我们可以省不少事，至少不用回溯。我们可以从主串的第5个字符开始，直接与字串的第3个字符比较。

我们总结一下经验，发现只要我们匹配过的串是对阵的，我们就可以不用主串，那么发现匹配过的不对称，该怎么办呢？

这里就需要另外一个技巧了，这个技巧需要极强的记忆力。我们将主串的每一处的对称性都记录下来。当发现不对称了，我们就递归的回溯，直到找到对称的：

![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kmp_5.png?raw=true)

其实，最终就是找到 j 应该指向i的位置。

上面所说的就是 KMP 的主要思想了。了解了这个思想，我们再来看看算法的实现。

我们先看这一段：

```c
void getNext(char * p, int * next)
{
    next[0] = -1;
    int i = 0, j = -1;
 
    while (i < strlen(p))
    {
        if (j == -1 || p[i] == p[j])
        {
            ++i;
            ++j;
            next[i] = j;
        }  
        else
            j = next[j];
    }
}
```

你能看出这个函数做了什么吗？这个函数其实就是使用 next 数组记录了主串从[0, i]的每个位置有多长是对称的。

**当 p[i] == p[j] 说明[0, i]这个串两端有字符相等的，又因为 p[i] != p[j] 的时候，j 被重置过了，所以可以保证此时[0, i] 的两头是对称的。**

那么，我们之后，就可以直接使用这个数组来进行判断了。

```c
public static int KMP(String main,String model,int[] next){
    int i = 0;
    int j = 0;
    while (i<main.length()&&j<model.length()){
        if(-1==j||main.charAt(i) == model.charAt(j)){
            i++;
            j++;
        }else {
            //不相等,滑动
            j = next[j];
        }
    }
    if(j==model.length()){
        //如果最后j到达模式串的尾部,则说明匹配上了
        return i - j;
    }else {
        return -1;
    }
}
```

这样就搞定了，是不是很简单呢！

上面的算法是我copy的，不保证能正确运行，只是我看了没发现什么问题就直接用了。

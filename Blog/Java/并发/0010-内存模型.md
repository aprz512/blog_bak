---
title: 0010-内存模型
date: 2019-8-19
tags: Java-并发
categories: 并发
---

在说内存模型之前，我们先来说下一CPU，对CPU有一定了解之后，再来说为何要有内存模型。



## CPU缓存一致性

我们知道CPU是用来执行计算机指令的，而指令中包含的数据是从主存（内存）当中读取的，它将读取的数据放入自己的寄存器中，然后执行操作，这个是因为CPU在寄存器上执行操作的速度远大于在主存上执行的速度。

虽然CPU访问寄存器的速度很快，但是每次执行新的指令的时候，又要重新从主存中读取数据。那么这就会产生一个问题：随着CPU技术的发展，CPU的运行速度越来越快，而内存的技术没有啥太大的改变，这就导致了CPU与内存的运行速度差距越来越大。换成人类时间举个例子，一个主频2.6G的CPU执行一个指令只需要1s，它从内存读取数据大概需要4分钟（这还假设它没有触发缺页异常）。

可以看到如果CPU只能从内存中读取数据的话，那么CPU技术发展的再快也没有用。那么有没有什么办法解决呢？显然是有的，不然我们的个人计算机也不会发展的那么迅速了。

就是给CPU加一个高速缓存，这样由于**局部性原理**，CPU只需要将部分数据保存在高速缓存中，就可以极大的缓解数据读取慢的问题（从高速缓存中读取数据与执行指令的速度在同一个数量级）。于是CPU工作方式如下：

**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。**

现在的CPU有的还会有多级缓存：L1，L2，L3。工作方式与普通的缓存一样，L1中找不到找L2，L2中找不到找L3。但是每一级缓存的速度相差比较大，L1与L2的速度就不在同一个数量级。**我们只需要知道CPU有一个高速缓存就好了**。

![](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png)

高速缓存解决了数据访问慢的问题，但是引入了新的问题：每个CPU有自己的缓存，每个缓存中的数据都是主存中的一份拷贝。如果多个CPU都同时从主存中读取了一样的数据，都更改了这个数据，那么当CPU将缓存中的数据写回主存会发生什么呢？具体会发生啥我也不知道，反正肯定会乱成一锅粥就对了。**这种问题叫做缓存一致性问题**。



这里说一个小知识：我们经常说的 4核8线程是什么意思？

> 4核显然是4个CPU核心，但是8线程是什么呢？难道一个CPU可以同时运行两个线程？
>
> 8线程指的是通过超线程技术，用一个物理核模拟两个虚拟核，在CPU核心没有满负荷运载时，其剩余用量可以模拟成虚拟的核心。



除了缓存一致性问题，还有别的导致多CPU运算出错（不符合我们的预期）的问题。比如：CPU指令优化导致的问题。比如，一个32位的系统读取 double 与 long 值的时候会分两次读，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值。



## 内存模型

为了保证共享内存的正确性，内存模型定义了共享内存系统中多线程程序读写操作行为的规范。主要是抽象出了3个概念：**可见性、有序性、原子性**。

这3个概念就是前人们总结出来的3个前置条件，我们要想在编写出一个符合期望的多线程程序，那么内存模型就需要提供一套解决方案来实现这3个条件。



## Java内存模型

Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。

Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问。

线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量。

工作内存中存储着主内存中的变量副本拷贝。

下面举几个例子来说明哪些变量储存在主内存，哪些变量储存在工作内存。注意不要把主内存，工作内存与堆栈搞混了。

![](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png)

- 原始类型的本地变量是储存在栈（在工作内存中）。
- 对象类型的本地变量储存在堆中（在主内存中），但是该类型的引用储存在栈中（在工作内存中）。
- 对象的成员变量（不管这个变量是基本类型还是对象类型）是放在堆中（在主内存中）。
- static变量以及类本身相关信息将会存储在方法区（在主内存中）。

JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。

![](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png)

在上面的图中，Object3对象肯定不是在 methodOne() 中创建的，所以它们指向同一个对象。

Object1 与 Object5 才是在 methodTwo() 中创建的，所以每个线程都创建了自己的对象。



## Java内存模型与实际内存的关系

对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分。

JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中或者CPU缓存或者寄存器中。

![](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png)



## Java内存模型保证了原子性、可见性、有序性

JMM主要是靠` happens-before` 原则，`sychronized`等同步锁， `volatile` 等关键字来保证原子性、可见性以及有序性。

下面是happens-before原则规则：

1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

这些东西读起来像是很理所当然的东西，但是却是并发编程的基石。就像高等数学学起来很费劲，1+1却是理所当然一样。


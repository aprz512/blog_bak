---
title: 0024-剖析同步器
date: 2019-8-23
tags: Java-并发
categories: 并发
---

前面，我们设计了简易版的信号量、锁等，它们虽然功能不一样，但是内部的差距却差不多。换句话说，它们内部的的基础部分是相同（或相似）的。了解这些基础部件能在设计同步器的时候给我们大大的帮助。这就是本文要细说的内容。

大部分同步器都是用来保护某个区域（临界区）的代码，这些代码可能会被多线程并发访问。要实现这个目标，同步器一般要支持下列功能：

- 状态
- 访问条件
- 状态变化
- 通知策略
- Test-and-Set 方法
- Set 方法

并不是所有同步器都包含上述部分，也有些并不完全遵照上面的内容。但通常你会看到一或多个类似的功能。



## 状态

**同步器中的状态是用来确定某个线程是否有访问权限。**

下面是Lock和BoundedSemaphore中的两个代码片段。

```diff
public class Lock{
+   //state is kept here
+   private boolean isLocked = false; 
    public synchronized void lock()
        throws InterruptedException{
        while(isLocked){
            wait();
        }
        isLocked = true;
    }
    ...
}
```

```diff
public class BoundedSemaphore {
+    //state is kept here
+    private int signals = 0;
    private int bound   = 0;

    public BoundedSemaphore(int upperBound){
        this.bound = upperBound;
    }
    public synchronized void take() throws InterruptedException{
        while(this.signals == bound) wait();
        this.signal++;
        this.notify();
    }
    ...
}
```



## 访问条件

访问条件决定调用`test-and-set`方法（下文会说到）的线程是否可以对状态进行设置。访问条件一般是基于同步器[状态](http://ifeve.com/anatomy-of-a-synchronizer/#state)的。通常是放在一个while循环里，以避免[虚假唤醒](http://ifeve.com/thread-signaling/#spurious_wakeups)问题。访问条件的计算结果要么是true要么是false。

这里有两个来自Lock和BoundedSemaphore的代码片段，它们都有访问条件。注意观察条件是怎样在while循环中检查的。

```diff
public class Lock{
    private boolean isLocked = false;
    public synchronized void lock()
        throws InterruptedException{
+        //access condition
+        while(isLocked){
            wait();
        }
        isLocked = true;
    }
    ...
}
```



##  状态变化

**一旦一个线程获得了临界区的访问权限，它得改变同步器的状态，让其它线程阻塞，防止它们进入临界区。**换而言之，这个状态表示正有一个线程在执行临界区的代码。其它线程想要访问临界区的时候，该状态应该影响到访问条件的结果。

这里有两个状态变化的代码片段：

```diff
public class Lock{

    private boolean isLocked = false;

    public synchronized void lock()
        throws InterruptedException{
        while(isLocked){
            wait();
        }
+        //state change
+        isLocked = true;
    }

    public synchronized void unlock(){
+        //state change
+        isLocked = false;
        notify();
    }
}
```

```diff
public class BoundedSemaphore {
    private int signals = 0;
    private int bound   = 0;

    public BoundedSemaphore(int upperBound){
        this.bound = upperBound;
    }

    public synchronized void take() throws InterruptedException{
        while(this.signals == bound) wait();
+        //state change
+        this.signals++;
        this.notify();
    }

    public synchronized void release() throws InterruptedException{
        while(this.signals == 0) wait();
+        //state change
+        this.signals--;
        this.notify();
    }
}
```


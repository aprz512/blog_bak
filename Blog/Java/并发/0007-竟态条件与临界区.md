---
title: 0007-竟态条件与临界区
date: 2019-08-18
tags: Java-并发
categories: 并发
---

在一个程序中运行多个线程本身不会有问题，有问题的是这些线程同时访问了同样的资源。

比如：同一个变量，同一个数据库。当然如果这些线程都只是读取，那不会有问题，但是如果有一个或者多个写线程就会有问题。

多线程同时执行下面的代码可能会出错：

```java
public class Counter {
	protected long count = 0;
	public void add(long value){
		this.count = this.count + value;   
	}
}
```

想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序：

```
从内存获取 this.count 的值放到寄存器
将寄存器中的值增加value
将寄存器中的值写回内存
```

假设线程交替执行：

```java
	this.count = 0;

   A:	读取 this.count 到一个寄存器 (0)
   B:	读取 this.count 到一个寄存器 (0)
   B: 	将寄存器的值加2
   B:	回写寄存器值(2)到内存. this.count 现在等于 2
   A:	将寄存器的值加3
   A:	回写寄存器值(3)到内存. this.count 现在等于 3
```

两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。

然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。

然后各自加了2和3，并分别写回内存。

最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。



## 竟态条件与临界区

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。

导致竞态条件发生的代码区称作临界区。

上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。

---
title: 并发介绍
date: 2019-08-18 11：11：11
tags: Java-并发
---

在远古时代，我们的计算机只有一个 CPU，而且一次只能运行一个程序。

接着多任务系统被引入，单个 CPU 可以同时运行多个程序了，虽然并不是真正意义上的“同一时间点”。它是这样工作的：多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。

从多任务系统开始，程序设计者就需要考虑该程序不能独占所有的CPU时间、所有的内存和其他计算机资源，因为别的程序也要运行。

再接着，多线程被引入：使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。但是需要注意的是，虽然名义上叫多线程，因为只有一个CPU，所以两个线程从来不会得到真正的并行执行。

（之所以能够这么设计，是因为 CPU 实在是太快了，看过 三体 么，里面的智子只有一个，但是却监控了整个地球，就是因为它跑的太快了，让人感觉到它无处不在，同样的，CPU 在切换线程的时候，我们根本就感觉不到）

再接着，多核 CPU 出现了，意味着不同的线程能被不同的CPU核得到真正意义的并行执行。以前的程序可能会出现一些从未见过的问题：因为多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。

![](http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png)

如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。


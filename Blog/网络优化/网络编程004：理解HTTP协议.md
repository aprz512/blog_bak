---
title: 网络编程004：理解HTTP协议
date: 2020-6-16
categories: 网络优化
---

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.jpeg](http://www.52im.net/data/attachment/forum/201806/15/144336adhfhh6ao1dfj9hj.jpeg)



### HTTP的工作过程

**HTTP请求响应模型：**

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.jpg](http://www.52im.net/data/attachment/forum/201806/15/150222j96nx292xu7nwz87.jpg)



**HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：**

1. 建立 TCP 连接：在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；
2. 客户端向服务器发送请求命令：一旦建立了TCP连接，客户端就会向服务器发送请求命令；
   例如：GET/sample/hello.jsp HTTP/1.1；
3. 客户端发送请求头信息：客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；
4. 服务器应答：客户端向服务器发出请求后，服务器会客户端返回响应；
   例如： HTTP/1.1 200 OK
   响应的第一部分是协议的版本号和响应状态码；
5. 服务器返回响应头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；
6. 服务器向客户端发送数据：服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；
7. 服务器关闭 TCP 连接：一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。



### HTTP协议基础

#### HTTP协议是不保存状态的

不保存状态为了更快地处理大量事务。

但是现在我们的很多业务都需要对通信状态进行保存。Cookie技术随之而来。

#### Cookie

服务端发送一个 Set-Cookie 首部字段，客户端就会保存 Cookie。

客户端后续的请求会在请求报文中带上 Cookie 值。

服务端会处理该 Cookie，用于辨别客户端的身份，做处理。

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_5.jpg](http://www.52im.net/data/attachment/forum/201806/15/150708wk6wefkkxs8gzwpq.jpg)

#### 持久链接与管线化

 最开始的 HTTP 协议，每次请求都会创建一个新的 TCP 连接，请求完成之后会断开 TCP 连接。如果一个页面里面有很多图片，就会浪费资源。

持久连接就是只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。

管线化就是在持久连接的基础上进一步提升请求响应时间：之前的 HTTP 请求都是串行的，一个请求接着一个响应，使用管线化之后可以一次发送多个 HTTP 请求（可以理解为批量 HTTP 请求），这样就不用等前一个请求返回响应了下一个才能开始。

注意管线化的请求发送顺序与响应顺序是一致的，不会乱序，这样就会出现一些问题，嗯，了解一下就行了。



#### 一些常见头部字段

##### 缓存相关

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.png](http://www.52im.net/data/attachment/forum/201806/15/162745p1cm8xqa6aczttvq.png)

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_3.png](http://www.52im.net/data/attachment/forum/201806/15/162757l6llgpk844ht4wjt.png)



Last-Modified：资源的最后修改日期。

>  Last-Modified 是由服务器往客户端发送的 HTTP 头，另一个 If-Modified-Since是由客户端往服务器发送的头。
>
> 再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了。

ETag：资源的标识，可以当成id来理解。它的作用与 Last-Modified 一样，但是它可以解决 Last-Modified 无法解决的一些问题。

> ETag 是由服务器往客户端发送的 HTTP 头，另一个 If-None-Match 是由客户端往服务器发送的头。
>
> 1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;
>
> 2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
>
> 3、某些服务器不能精确的得到文件的最后修改时间；



##### 范围请求

```
GET  /bigfile.html  HTTP/1.1
Host: [url=http://www.sample.com]www.sample.com[/url]
Range: bytes=20224-
···
```

假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。

有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，**那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过**。

#### 内容编码

就是使用压缩技术对报文主体进行压缩，然后再进行传输。

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_1.png](http://www.52im.net/data/attachment/forum/201806/15/160444jrcu77utb4fg1733.png)

压缩的是上图左边的主体部分。

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.jpg](http://www.52im.net/data/attachment/forum/201806/15/160922rjfhtzvhqdrt3vt1.jpg)

#### 传输编码-分块编码

使用传输编码是为了改变报文中的数据在网络上传输的方式。

拿分块编码来举例：

当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。

分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号。

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.png](http://www.52im.net/data/attachment/forum/201806/15/161011bzsn1hzlt3nxgp3h.png)

#### 网关

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.png](http://www.52im.net/data/attachment/forum/201806/15/162822u9kop17v57v7v1kw.png)

将 HTTP 流量转换成其他的协议。

#### 隧道

![网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_5.png](http://www.52im.net/data/attachment/forum/201806/15/162831nzz7vototoi1zoww.png)

HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。

上面这句话，我第一看到是一脸懵逼了，我查了一些资料，总算了解一点了。

我们先了解一下什么是 HTTP 代理服务器。

在一次请求中，客户端（浏览器）明文的请求代理服务器。代理服务器明文去请求远端服务器（网站），拿到返回结果，再将返回结果返回给客户端。代理服务器可以看到请求中的任何东西。

那么你可以想一下，如果是 HTTPS 请求会怎么样呢？

如果我们想在复用现有的HTTP proxy的传输方式来代理HTTPS流量，那么就会变成浏览器和代理握手跑TLS，代理拿到明文的请求报文，代理和网站握手跑TLS。但是代理没有，也不可能有网站的私钥证书，所以这么做会导致浏览器和代理之间的TLS无法建立，证书校验根本通不过。HTTP tunnel解决了这个问题，代理服务器不再作为中间人，不再改写浏览器的请求，而是把浏览器和远端服务器之间通信的数据原样透传，这样浏览器就可以直接和远端服务器进行TLS握手并传输加密的数据。





### 参考文档

http://www.52im.net/thread-1677-1-1.html

https://www.cnblogs.com/flysnow-z/archive/2012/08/17/2644420.html

https://www.zhihu.com/question/21955083